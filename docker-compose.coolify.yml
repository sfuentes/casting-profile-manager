# Coolify Production Deployment
#
# HOW TO USE IN COOLIFY:
#   1. Create a new "Docker Compose" resource in Coolify
#   2. Point it at this repository and select this file as the compose file
#   3. Set the required environment variables in the Coolify UI (see .env.coolify.example)
#   4. Coolify will handle SSL termination via its built-in Traefik proxy
#
# PORTS:
#   - Frontend (Nginx):  exposed on SERVICE_FQDN_FRONTEND (your app domain)
#   - Backend API:       exposed on SERVICE_FQDN_BACKEND  (your API subdomain)
#   - MongoDB:           internal only (not exposed publicly)
#
# IMPORTANT: VITE_API_URL must be your public API URL (e.g. https://api.yourdomain.com/api)
#            because it is compiled into the frontend bundle at build time.

services:
  # ─── MongoDB ────────────────────────────────────────────────────────────────
  mongodb:
    image: mongo:7.0
    container_name: casting-mongodb
    restart: unless-stopped
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
      MONGO_INITDB_DATABASE: darsteller-manager
    volumes:
      - mongodb_data:/data/db
      - mongodb_config:/data/configdb
      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    networks:
      - casting-network
    healthcheck:
      test: echo 'db.runCommand("ping").ok' | mongosh localhost:27017/test --quiet
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 40s

  # ─── Backend API ─────────────────────────────────────────────────────────────
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: casting-backend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 5000
      MONGO_URI: mongodb://${MONGO_ROOT_USERNAME:-admin}:${MONGO_ROOT_PASSWORD}@mongodb:27017/darsteller-manager?authSource=admin
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRES_IN: ${JWT_EXPIRES_IN:-7d}
      JWT_COOKIE_EXPIRE: ${JWT_COOKIE_EXPIRE:-7}
      # Set this to your public frontend domain, e.g. https://app.yourdomain.com
      FRONTEND_URL: ${FRONTEND_URL}
      UPLOAD_DIR: ./uploads
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10}
      RATE_LIMIT_WINDOW_MS: ${RATE_LIMIT_WINDOW_MS:-600000}
      RATE_LIMIT_MAX: ${RATE_LIMIT_MAX:-100}
      PUPPETEER_EXECUTABLE_PATH: /usr/bin/chromium-browser
    volumes:
      - backend_uploads:/app/uploads
      - backend_logs:/app/logs
    depends_on:
      mongodb:
        condition: service_healthy
    networks:
      - casting-network
    expose:
      - "5000"
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:5000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 40s

  # ─── Frontend (React → Nginx) ────────────────────────────────────────────────
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        # This URL is baked into the JS bundle at build time by Vite.
        # It must be the publicly reachable URL of the backend API.
        VITE_API_URL: ${VITE_API_URL}
    container_name: casting-frontend
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
    networks:
      - casting-network
    expose:
      - "80"
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost/"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s

volumes:
  mongodb_data:
    driver: local
  mongodb_config:
    driver: local
  backend_uploads:
    driver: local
  backend_logs:
    driver: local

networks:
  casting-network:
    driver: bridge
